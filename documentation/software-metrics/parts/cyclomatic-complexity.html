<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

    <meta name="description" content="PHP Depend - Software Metrics for PHP. Metrics analysis tool for software developed in PHP."/>
    <meta name="keywords" content="PHP Depend, metrics, CodeRank, Cyclomatic Complexity, NPath Complexity, Quality Assurance, Design, Maintenance"/>
    <meta name="author" content="Manuel Pichler"/>
    <meta name="language" content="en"/>
    <meta name="date" content="Tue, 14 May 2024 18:08:30 +0000"/>
    <meta name="robots" content="all"/>

    <link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"/>
    <meta name="DC.title" content="News"/>
    <meta name="DC.creator" content="Manuel Pichler"/>
    <meta name="DC.date" content="Tue, 14 May 2024 18:08:30 +0000"/>
    <meta name="DC.rights" content="CC by-nc-sa"/>

    <link rel="canonical" href="https://pdepend.org/news.html"/>
    <link rel="icon" href="/images/favicon.png" type="image/png"/>

    <link rel="Stylesheet" type="text/css" href="/css/screen.css" media="screen"/>
    <link rel="Stylesheet" type="text/css" href="/css/print.css" media="print"/>

    <title>PHP Depend - Software Metrics for PHP: News</title>
</head>
<body>
<h1 class="viewport">
    <a href="/">PHP Depend - Software Metrics for PHP</a>
</h1>
<div class="header">
    <div class="viewport">
        <ul class="navigation">
            <li>
                <a href="/news.html" title="News">News</a>
            </li>
            <li>
                <a href="/documentation/getting-started.html" title="Documentation">Documentation</a>
            </li>
            <li>
                <a href="/screenshots.html" title="Screenshots">Screenshots</a>
            </li>
            <li>
                <a href="/download/index.html" title="Download">Download</a>
            </li>
            <li>
                <a href="/support.html" title="Support &amp; Contact">Support &amp; Contact</a>
            </li>
        </ul>
    </div>
</div>


<div class="viewport content">
    <p>The <em>Cyclomatic Complexity</em> number [#cabeccn]_ or short <em>CCN</em>
is one of the oldest complexity metrics. The first time this
software metric was mentioned was 1976 by Thomas J. McCabe.
This metric counts the available decision paths in a software
fragment to determine its complexity. Each decision path
starts with one of the conditional statements from the
following list, so that it is fairly easy to detect them in
existing source code.</p>
<ul><li>?</li>
<li>case</li>
<li>elseif</li>
<li>for</li>
<li>foreach</li>
<li>if</li>
<li>while</li>
</ul>

<p>A look at this list of statements may result in the questions:
Is this list wrong, it doesn't list <code>else</code> and <code>default</code>?
But it is correct. The assumption is that both statements
will contain the default execution path of a program which<br />also exists when there are no special cases to capture.</p>
<p>Each decision path gets the value <em>1</em> and the sum of all these
values represents the Cyclomatic Complexity of the analyzed
software fragment. Note that each function and method also<br />counts with a value of <em>1</em> With this knowledge we can now<br />calculate the complexity of the following example code: :</p>
<pre><code class="">&lt;?php                                 
//                                                         | CCN
// -------------------------------------------------------------
class CyclomaticComplexityNumber                        // |  0
{                                                       // |  0
    public function example( $x, $y )                   // |  1
    {                                                   // |  0
        if ( $x &gt; 23 || $y &lt; 42 )                       // |  1
        {                                               // |  0
            for ( $i = $x; $i &gt;= $x &amp;&amp; $i &lt;= $y; ++$i ) // |  1
            {                                           // |  0
            }                                           // |  0
        }                                               // |  0
        else                                            // |  0
        {                                               // |  0
            switch ( $x + $y )                          // |  0
            {                                           // |  0
                case 1:                                 // |  1
                    break;                              // |  0
                case 2:                                 // |  1
                    break;                              // |  0
                default:                                // |  0
                    break;                              // |  0
            }                                           // |  0
        }                                               // |  0
    }                                                   // |  0
    file_exists('/tmp/log') or touch('/tmp/log');       // |  0
}                                                       // |  0
// -------------------------------------------------------------
//                                                         |  5
</code></pre>
<p>Based on the previous definition the Cyclomatic Complexity<br />Number of the example code example is <em>5</em>. But you may have
noticed that this approach does not capture all decision paths
that exist. We haven't catched those paths that came from the
by the boolean expression <code>||</code> line 8 and <code>&amp;&amp;</code> line 10, and<br />the logical <code>or</code> expression in line 27. A variation of the
Cyclomatic Complexity Number that also captures those paths
is the so called CCN2. The CCN2 is the most widely used
variation of this software metrics. Tools like PHPUnit, PMD
and Checkstyle report it as Cyclomatic Complexity of an
analyzed software fragment.</p>
<p>Now we get a complexity value of <em>8</em> when we apply the CCN2<br />to the previous example, what is a growth of the software's<br />complexity of 60%.</p>
<p>Due to the fact that Cyclomatic Complexity Number was<br />originally invented for procedural programming languages,<br />this definition for the Cyclomatic Complexity Number still<br />misses one element to measure the complexity of an object<br />oriented software system. With the concept of exceptions a<br />software gets additional decision paths for each <code>catch</code>
statement used in the source code. While <code>try</code> contains<br />the code for the regular execution code without special<br />cases, similar to <code>else</code> and <code>default</code> statements.</p>
<ul><li>?</li>
<li>&amp;&amp;</li>
<li>||</li>
<li>or</li>
<li>and</li>
<li>xor</li>
<li>case</li>
<li>catch</li>
<li>elseif</li>
<li>for</li>
<li>foreach</li>
<li>if</li>
<li>while</li>
</ul>

<p>Now that we know what the Cyclomatic Complexity Number is,
what can we do with the measured information? We can find<br />the complexity hotspots in a system, for example the top<br />ten artifacts with the highest complexity, but this is only
important during an initial analyses phase to get the big<br />picture of an application. For a continuous inspection this
information is not so important. A continuous analyses
requires thresholds that help to categories calculated<br />values. During the time four values have emerged as good<br />thresholds for the Cyclomatic Complexity Number of a<br />software system.</p>
<ul><li>A software fragment with a CCN value between <em>1-4</em> has
  low complexity.</li>
<li>A complexity value between <em>5-7</em> is moderate and still
  easy to understand.</li>
<li>Everything between <em>6-10</em> has a high complexity, while
  everything greater <em>10</em> is very complex and hard to<br />  understand.</li>
</ul>

<p>You may ask, why should I care about the complexity of a
software system, where is the value of benefit in this
metric?</p>
<p>Mostly the complex parts of an application contain business
critical logic. But this complexity has negative impacts on<br />the readability and understandability of source code. Those
parts will normally become a maintenance and bug fixing
nightmare, because no one knows all the constraints, side
effects and what's exactly going on in that part of the<br />software. This situation results in the well known saying
<em>&quot;Never touch a running system&quot;</em> which in turn mostly ends<br />in copy&amp;paste programming. The situation can even become
more critical when the original author leaves the<br />development team or the company.</p>
<p>Example:
Finally a small example how to apply the new knowledge<br />about the Cyclomatic Complexity Number, thresholds and the
negative impacts of complex software to an existing<br />development process. The following source listing shows<br />a complex method taken from PHP_Depend's source. This method
has a Cyclomatic Complexity Number of <em>16</em> and I must admit
that the original author needed some time to understand what<br />was going on in this method. :</p>
<pre><code class="">&lt;?php
// ...
private function _countCalls(PHP_Depend_Code_AbstractCallable $callable)
{
    $callT  = array(
        \PDepend\Source\Tokenizer\Tokens::T_STRING,
        \PDepend\Source\Tokenizer\Tokens::T_VARIABLE
    );
    $chainT = array(
        \PDepend\Source\Tokenizer\Tokens::T_DOUBLE_COLON,
        \PDepend\Source\Tokenizer\Tokens::T_OBJECT_OPERATOR,
    );

    $called = array();

    $tokens = $callable-&gt;getTokens();
    $count  = count($tokens);
    for ($i = 0; $i &lt; $count; ++$i) {
        // break on function body open
        if ($tokens[$i]-&gt;type === \PDepend\Source\Tokenizer\Tokens::T_CURLY_BRACE_OPEN) {
            break;
        }
    }

    for (; $i &lt; $count; ++$i) {
        // Skip non parenthesis tokens
        if ($tokens[$i]-&gt;type !== \PDepend\Source\Tokenizer\Tokens::T_PARENTHESIS_OPEN) {
            continue;
        }
        // Skip first token
        if (!isset($tokens[$i - 1]) || !in_array($tokens[$i - 1]-&gt;type, $callT)) {
            continue;
        }
        // Count if no other token exists
        if (!isset($tokens[$i - 2]) &amp;&amp; !isset($called[$tokens[$i - 1]-&gt;image])) {
            $called[$tokens[$i - 1]-&gt;image] = true;
            ++$this-&gt;_calls;
            continue;
        } else if (in_array($tokens[$i - 2]-&gt;type, $chainT)) {
            $identifier = $tokens[$i - 2]-&gt;image . $tokens[$i - 1]-&gt;image;
            for ($j = $i - 3; $j &gt;= 0; --$j) {
                if (!in_array($tokens[$j]-&gt;type, $callT)
                    &amp;&amp; !in_array($tokens[$j]-&gt;type, $chainT)
                ) {
                    break;
                }
                $identifier = $tokens[$j]-&gt;image . $identifier;
            }

            if (!isset($called[$identifier])) {
                $called[$identifier] = true;
                ++$this-&gt;_calls;
            }
        } else if ($tokens[$i - 2]-&gt;type !== \PDepend\Source\Tokenizer\Tokens::T_NEW
            &amp;&amp; !isset($called[$tokens[$i - 1]-&gt;image])
        ) {
            $called[$tokens[$i - 1]-&gt;image] = true;
            ++$this-&gt;_calls;
        }
    }
}
</code></pre>
<p>The first thing to do is to make sure that the test suite<br />is good enough to ensure that the required refactorings<br />will not change the public behavior of the component or
class. When this is done and we are sure our that api
breaks will be detected by the test suite we can start to
extract logic into separate methods.</p>
<p>The following example shows the result of the refactoring: :</p>
<pre><code class="">&lt;?php
// ...
private function _countCalls(PHP_Depend_Code_AbstractCallable $callable)
{
    $called = array();

    $tokens = $callable-&gt;getTokens();
    $count  = count($tokens);
    for ($i = $this-&gt;_findOpenCurlyBrace($tokens); $i &lt; $count; ++$i) {

        if ($this-&gt;_isCallableOpenParenthesis($tokens, $i) === false) {
            continue;
        }

        if ($this-&gt;_isMethodInvocation($tokens, $i) === true) {
            $image = $this-&gt;_getInvocationChainImage($tokens, $i);
        } else if ($this-&gt;_isFunctionInvocation($tokens, $i) === true) {
            $image = $tokens[$i - 1]-&gt;image;
        } else {
            $image = null;
        }

        if ($image !== null) {
            $called[$image] = $image;
        }
    }

    $this-&gt;_calls += count($called);
}
</code></pre>
<p>The subjective feeling of readability heavily depends on the<br />complexity of control structures, as we can see by a<br />comparison of the original and the refactored version of the<br />method example. The new version with its Cyclomatic Complexity
Number of <em>5</em> is much easier to read and understand.</p>
<blockquote><p>IEEE Transactions on Software Engineering; <em>A Complexity Measure</em>;
Thomas J. McCabe; 1976</p>
</blockquote>
</div>
<div class="footer">
    <div class="viewport">
        <span class="follow">
            <a href="https://twitter.com/pdepend" title="Follow on Twitter" class="twitter-follow" target="_blank">
                <i></i> Follow @pdepend
            </a>
            <a rel="me" href="https://phpc.social/@pdepend" title="Follow on Mastodon" class="mastodon-follow" target="_blank">
                <i></i> Follow @pdepend@phpc.social
            </a>
        </span>
        <div class="license">
            By <strong>Manuel Pichler</strong>
            licensed under <a href="https://opensource.org/licenses/bsd-license.php" title="BSD-3-Clause">BSD-3-Clause</a>
        </div>
        <div class="clear"></div>
    </div>
</div>
</body>
</html>
